># Концепция выражений
## В языке DORL всё является выражением, которое что либо возвращает
```1C
"К примеру, здесь в консоль выведется строка <Привет мир!>"
"т.к. блок (нч и кц) возвращает последний элемент в последовательности выражений"

а = 
    если 1 > 0: 
        б = "Привет мир!";
печать(а);

```

># Переменные
## Переменная возращает значение, которое в ней содержится или нулевой объект, если она пуста

># Числа
## В языке DORL дробные и целые числа объединены в один общий тип.
```1C
"Из этого выходит, что выражение:";
17.0 == 17;
"вернет логическое Истина";
```

## Операции над числами:
### Сложение и вычитание
```1c
a = 17-3;
```
### Умножение и деление
```1c
арбуз = 1/3;
"арбуз будет равен: 0.333333";
```

### Целочисленное деление и остаток
```1c
арбуз = 18%11;
"арбуз будет равен: 7";

банан = 8//3;
"банан будет равен: 2";
```

### Сравнение чисел (всегда возвращает логический тип)
```1c
1 > 0; "Истина";

-2 == 4; "Ложь";
-2 != 4; "Истина";
```

### На данный момент методов у чисел в DORL нет.

># Строки
## Вид
```1c
"банан";
```

## Операции
### Конкатенация (сложение строк) O(n+m)
```1c
арбуз = "Я" + " и " + "ты";
"арбуз будет равен: Я и ты";
```

### Сравнение O(1) за счет хеширования
```1c
"банан" == "банан";
"банан" != "банан";
```

## Методы
### перевернуть() - переворачивает строку за O(n)
### срез(индекс1, индекс2) - срезает строку от индекс1 до индекс2 включительно за O(1)



## Символ "\n" и "\\\\".
```1c
а = "банан\n Арбуз\\Дыня";
печать(а);
"выведет:";
"банан";
"Арбуз\Дыня";
```

># Списки
## Операции
### Конкатенация (сложение строк) O(n+m)
```1c
арбуз = [1,2] + [2,3];
"арбуз будет равен: [1,2,2,3]";
```

## Методы
### добавить(el, i) - делает так, что в списке el начинает занимать позицию i. O(log n)
```1c
а = [1,2,3];
а.добавить("банан", -1);
"а будет равно: [1,2,3, банан]";
```

># Индекс
## К спискам и строкам можно обращаться по индексу, которые начинаются с 0. Также индекс может быть отрицательным
## O(1) для строк и O(log n) для списков
```1c
а = [18,3,"банан", 4];
печать(а[2][-1]);
"будет выведена буква н"
```

># Последовательности
## Вид
```1c
нч
    <выражение>;
    <выражение>;
кц
```

## Важно!!!
### После каждого выражения внутри последовательности должно стоять ";".
### Глобальное пространство также является выражением последовательности

># Ветвление
## Вид
```1c
если <выражение>: <выражение> иначе <выражение>
```
### <иначе> не является обязательным. 

># Цикл while. Выполнятся пока условие истино
## Вид
```1c
пока <выражение> : <выражение>
```

># Цикл foreach. Итерируется по списку (или строке)
## Вид
```1c
для ИМЯ из СПИСОК : выражение
```

># Инструкции <выйти> и <продолжить>
## возвращают себя, пока не дойдут до выражения цикла
## <выйти> заверщает исполнение цикла (аналог break)
## <продолжить> продолжает цикл (аналог continue)

># Логический тип
## <Истина>, которое отвечает за логическое true и <Ложь>, которое отвечает за логическое false
## Операции
```1c
Истина и Ложь "аналог логического and"
Истина или Ложь "аналог логического or"
```
### также операции сравнения <==> и <!=>

># Объявление функции (функции не копируются)
```1c
функ ИМЯ1(ИМЯ2, ИМЯ3, ...): <выражение>
```

># Вызов функции
```1c
ИМЯ(арг1, арг2, ...)
```

># Возвращение <вернуть>
## возвращает себя, пока не выйдет из функции. После вернет объект
## Вид
```1c
вернуть <выражение>
```

># Объект
## Создает объект, который может быть унаследован 
## Вид
```1c
объект ИМЯ : <выражение>

"если хотип унаследовать объект с именем ALFA:"

объект ИМЯ(ALFA) : <выражение>
```

># Вызов метода
## Осуществляется через ИМЯ.поле
## Вид
```1c
объект ворона:
    функ каркать(): печать("кар"!\n);

ворона.каркать();
"выведет: кар!";
```

># Присвоение
## присваивает левому выражению правое (создаваю копию правого).
## Вид
```1c
ф = [1,2,3];
а = ф;
"а и ф не ссылаются на один и тот же список"
```


